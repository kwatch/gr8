#!/usr/bin/env ruby
# -*- coding: utf-8 -*-

###
### gr8 -- a great command-line utility powered by Ruby
###
### $Release: 0.0.0 $
### $Copyright: copyright(c) 2015 kuwata-lab.com all rights reserved $
### $License: MIT License $
###

require "optparse"


class String

  def q
    #; [!ejo5y] quotes string with single-quoation.
    #; [!ageyj] escapes single-quotation characters.
    "'%s'" % self.gsub(/'/) { "\\'" }
  end

  def qq
    #; [!wwvll] quotes string with double-quotation.
    #; [!rc66j] escapes double-quotation characters.
    '"%s"' % self.gsub(/"/) { '\\"' }
  end

end


class Object

  def _
    #; [!wvemx] returns self object.
    self
  end

end


def fu
  #; [!ktccp] returns FileUtils class object.
  require "fileutils" unless defined?(FileUtils)
  FileUtils
end


module Enumerable

  def transform(&block)
    #; [!peitw] similar to map() or collect(), make each item as self in block.
    collect {|x| x.instance_exec(x, &block) }
  end
  alias xf transform

  alias __map map
  def map(&block)
    #; [!zfmcx] each item is available as self in block of map().
    __map {|x| x.instance_exec(x, &block) }
  end

  alias __select select
  def select(&block)
    #; [!41hap] each item is available as self in block of select().
    __select {|x| x.instance_exec(x, &block) }
  end

  def sum
    #; [!9izc1] returns sum of numbers.
    inject(0, :+)
  end

  def sum_i
    #; [!01ehd] returns sum of integers, converting values into integer.
    inject(0) {|t, x| t += x.to_i }
  end

  def sum_f
    #; [!kplnt] returns sum of floats, converting values into float.
    inject(0.0) {|t, x| t += x.to_i }
  end

  def avg
    #; [!pvi8h] returnns average of numbers.
    #; [!poidi] returns nil when no numbers.
    i = 0
    sum = inject(0) {|t, n| i += 1; t += n }
    i == 0 ? nil : sum.to_f / i
  end

  def avg_i
    #; [!btiat] returns average of numbers, converting values into integer.
    #; [!892q9] returns nil when no numbers.
    i = 0
    sum = inject(0) {|t, x| i += 1; t += x.to_i }
    i == 0 ? nil : sum.to_f / i
  end

  def avg_f
    #; [!oqpmc] returns average of numbers, converting values into float.
    #; [!9bckq] returns nil when no numbers.
    i = 0
    sum = inject(0) {|t, x| i += 1; t += x.to_f }
    i == 0 ? nil : sum.to_f / i
  end

  def xsplit(pat=nil)
    #; [!1pz77] splits each lines with pattern.
    #; [!wte7b] if block given, use its result as index.
    if block_given?
      idx = yield
      collect {|s| s.split(pat)[idx] }
    else
      collect {|s| s.split(pat) }
    end
  end

  def sed(pat, str=nil, &block)
    #; [!c7m34] replaces all patterns found in each line with str or block.
    if block_given?
      collect {|s| s.sub(pat, &block) }
    else
      collect {|s| s.sub(pat, str) }
    end
  end

  def gsed(pat, str=nil, &block)
    #; [!9lzjv] replaces first pattern found in each line with str or block.
    if block_given?
      collect {|s| s.gsub(pat, &block) }
    else
      collect {|s| s.gsub(pat, str) }
    end
  end

  def paths(&block)
    #; [!t55ce] collects Pathname objects when block argument is not passed.
    #; [!yjkm5] yields Pathname objects when block argument is passed.
    #; [!4kppy] self is Patname object in block argument.
    require "pathname" unless defined?(Pathname)
    if block_given?
      collect {|s| x = Pathname(s); x.instance_exec(x, &block) }
    else
      collect {|s| Pathname(s) }
    end
  end

  def move_to(verbose=true, &block)
    __move_to("move_to", verbose, false, false, &block)
  end

  def move_to!(verbose=true, &block)
    __move_to("move_to!", verbose, true, false, &block)
  end

  def mkdir_and_move_to(verbose=true, &block)
    __move_to("mkdir_and_move_to", verbose, false, true, &block)
  end

  def mkdir_and_move_to!(verbose=true, &block)
    __move_to("mkdir_and_move_to!", verbose, true, true, &block)
  end

  private

  def __move_to(meth, verbose, overwrite, mkdir, &block)
    #; [!n0ubo] block argument is required.
    #; [!40se5] block argument is required.
    #; [!k74dw] block argument is required.
    #; [!z9yus] block argument is required.
    block  or
      raise ArgumentError.new("#{meth}(): block argument required.")
    require "fileutils" unless defined?(FileUtils)
    existing = nil
    collect {|fpath|
      #; [!qqzqz] trims target file name.
      fpath.strip!
      #; [!nnud9] destination directory name is derived from target file name.
      dirpath = fpath.instance_exec(fpath, &block)
      #; [!ey3e4] if target directory name is nil or empty, skip moving file.
      if ! dirpath || dirpath.empty?
        msg = "Skip: target directory name is nil or empty (file: '#{fpath}')"
      #; [!i5jt6] if destination directory exists, move file to it.
      elsif dirpath == existing || File.directory?(dirpath)
        msg = nil
      #; [!azqgk] if there is a file that name is same as desination directory, skip.
      elsif File.exist?(dirpath)
        msg = "Skip: directory '#{dirpath}' not a directory"
      #; [!b9d4m] if destination directory doesn't exist, creates it.
      elsif mkdir
        FileUtils.mkdir_p(dirpath)
        msg = nil
      #; [!rqu5q] if destinatio directory doesn't exist, skip.
      else
        msg = "Skip: directory '#{dirpath}' not exist"
      end
      #
      if msg.nil?
        new_fpath = File.join(dirpath, File.basename(fpath))
        #; [!0gq9h] if destination file already exist, skip.
        exist_p = File.exist?(new_fpath)
        if exist_p && ! overwrite
          msg = "Skip: destination file '#{new_fpath}' already exist."
        #; [!ebdqh] overwrite destination file even if it exists.
        else
          File.rename(fpath, new_fpath)
          existing = dirpath
          #; [!n7a1q] prints target file and destination directory when verbose mode.
          #; [!itsh0] use 'Move!' instead of 'Move' when overwriting existing file.
          move = exist_p ? "Move!" : "Move"
          msg = "#{move}: '#{fpath}' => '#{dirpath}'" if verbose
        end
      end
      msg
    }.reject {|s| s.nil? }
  end

end


class Enumerator::Lazy

  alias __map map
  def map(&block)
    #; [!drgky] each item is available as self in block of map().
    __map {|x| x.instance_exec(x, &block) }
  end

  alias __select select
  def select(&block)
    #; [!uhqz2] each item is available as self in block of map().
    __select {|x| x.instance_exec(x, &block) }
  end

end


module Gr8

  VERSION = "$Release: 0.0.0 $".split()[1]

  HELP = <<'END'
%{script} -- great command-line utility powered by Ruby

Usage:
  %{script} [options] ruby-code

Options:
  -h, --help             : print help
  -v, --version          : print version
  -r, --require=lib[,lib2,...]  : require libraries

Example:
  $ cat data
  Haruhi   100
  Mikuru    80
  Yuki     120
  $ cat data | %{script}s 'map{|s|s.split()[1]}'
  100
  80
  120
  $ cat data | %{script}s 'map{split()[1].to_i}.sum'
  300
  $ cat data | %{script}s 'map{split[1]}.sum_i'
  300

See https://github.com/kwatch/gr8 for details.
END


  module Util

    module_function

    def define_singleton_methods_on(stdin)
      (class << stdin; self; end).class_eval do
        #; [!zcxh1] removes '\n' from each line automatically.
        alias __each_orig each
        def each
          __each_orig {|s| s.chomp!; yield s }
        end
        alias __each_new each
        #; [!i7npb] $1, $2, ... are available in grep() block argument.
        #; [!vkt64] lines are chomped automatically in grep() if block is not given.
        def grep(pattern, &block)
          if pattern.is_a?(Regexp) && block
            (class << self; self; end).class_eval { alias each __each_orig }
          end
          super(pattern, &block)
        end
      end
    end

  end


  class EnumWrapper
    include Enumerable

    def initialize(enum, separator=nil, column=nil)
      @_base      = enum
      @_separator = separator
      @_column    = column
    end

    def each
      #; [!hloy1] splits each line into array.
      #; [!c22km] chomps each lin before splitting.
      #; [!m411f] selects column when column number specified.
      sep = @_separator
      col = @_column
      if @_column
        index = @_column - 1
        @_base.each {|s| s.chomp!; yield s.split(sep)[index] }
      else
        @_base.each {|s| s.chomp!; yield s.split(sep) }
      end
    end

  end


  class App

    def run(*args)
      #
      begin
        opts = parse_options(args)
      rescue ::OptionParser::ParseError => ex
        #$stderr.puts "#ERROR (#{script_name()}): #{ex.args.is_a?(Array) ? ex.args.join(' ') : ex.args}: #{ex.reason}"
        $stderr.puts "#ERROR (#{script_name()}): #{ex.message}"
        return 1
      end
      #
      output = handle_opts(opts)
      if output
        puts output
        return 0
      end
      #
      errmsg = validate_args(args)
      if errmsg
        $stderr.puts "ERROR (#{script_name()}): #{errmsg}"
        return 1
      end
      #
      $IN = $stdin.lazy
      Util.define_singleton_methods_on($IN)
      #; [!r69d6] executes ruby code with $stdin.lazy as self.
      code = args[0]
      filename = "<#{script_name()}>"
      val = $IN.instance_eval(code, filename)
      #; [!hsvnd] prints nothing when result is nil.
      #; [!eiaa6] prints each item when result is Enumerable.
      #; [!6pfay] prints value when result is not nil nor Enumerable.
      case val
      when nil        ; nil
      when Enumerable ; val.each {|x| puts x }
      else            ; puts val
      end
      #; [!h5wln] returns 0 as status code when executed successfully.
      return 0
    end

    def main(argv=ARGV)
      #; [!w9kb8] exit with status code 0 when executed successfully.
      #; [!nbag1] exit with status code 1 when execution failed.
      args = argv.dup
      status = run(*args)
      exit status
    end

    private

    def script_name
      @script_name ||= File.basename($0)
    end

    def parse_options(args)
      #; [!5efp5] returns Hash object containing command-line options.
      #; [!wdzss] modifies args.
      opts = {}
      parser = OptionParser.new
      parser.on("-h", "--help")    {|v| opts[:help]    = true }
      parser.on("-v", "--version") {|v| opts[:version] = true }
      parser.on("-r", "--require=libname") {|v| opts[:require] = v }
      parser.parse!(args)
      return opts
    end

    def handle_opts(opts)
      #; [!33bj3] prints help message when '-h' or '--help' specified.
      if opts[:help]
        return HELP % {script: script_name()}
      end
      #; [!2tfh5] prints version string when '-v' or '--version' specified.
      if opts[:version]
        return VERSION
      end
      #; [!1s7wm] requires libraries when '-r' or '--require' specified.
      if opts[:require]
        opts[:require].split(/,/).each do |libname|
          libname.strip!
          require libname
        end
      end
      nil
    end

    def validate_args(args)
      #; [!7wqyh] prints error when no argument.
      #; [!bwiqv] prints error when too many argument.
      if args.length == 0
        return "argument required."
      elsif args.length > 1
        return "too many arguments."
      end
      nil
    end

  end


end


if __FILE__ == $0
  Gr8::App.new.main()
end
