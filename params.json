{"name":"Gr8","tagline":"a great command-line utility powered by Ruby","body":"# About\r\n\r\n(Release: $Release: 0.0.0 $)\r\n\r\ngr8 (pronounce as _greight_ or _great_) is a great command-line utility powered by Ruby.\r\nYou can use gr8 instead of sed or awk.\r\n\r\n\r\n## Installation\r\n\r\n    $ gem install gr8\r\n\r\nOr:\r\n\r\n    $ curl -O http://bit.ly/gr8_rb\r\n    $ mv gr8_rb gr8\r\n    $ chmod a+x gr8\r\n    $ sudo mv gr8 /usr/local/bin\r\n\r\n\r\n## Usage\r\n\r\nUsage: gr8 _[options]_ ruby-code\r\n\r\nOptions:\r\n\r\n* -h, --help        : show help\r\n* -v, --version     : show version\r\n* -r lib[,lib2,...] : require libraries\r\n* -F[regexp]        : separate each line with separator\r\n* -C N              : select column (1-origin)\r\n\r\n\r\n## Example 1: Aggregation\r\n\r\nData file:\r\n\r\n    $ cat data\r\n    Haruhi  100\r\n    Mikuru   80\r\n    Yuki    120\r\n\r\nPrints each line (`gr8` command prints expression value automatically when non-nil):\r\n\r\n    $ cat data | gr8 '$stdin.lazy.map{|s| s }'\r\n    Haruhi  100\r\n    Mikuru   80\r\n    Yuki    120\r\n\r\n`$stdin.lazy` is omissible because `gr8` command uses it as current context (=`self`):\r\n\r\n    $ cat data | gr8 'map{|s| s }'\r\n    Haruhi  100\r\n    Mikuru   80\r\n    Yuki    120\r\n\r\nSelect second column:\r\n\r\n    $ cat data | gr8 'map{|s| s.split()[1] }'\r\n    100\r\n    80\r\n    120\r\n\r\n`map{|s|s.split()}` can be `map{split()}` in `gr8` command\r\nbecause `gr` extends `map()` and `select()` to set each item as self\r\nin block arguments of them:\r\n\r\n    $ cat data | gr8 'map{split()[1]}'\r\n    100\r\n    80\r\n    120\r\n\r\nCalculates total of numbers:\r\n\r\n    $ cat data | gr8 'map{split()[1]}.map(&:to_i).inject(0,:+)'\r\n    300\r\n\r\n`sum()` is a short-hand for `inject(0,:+)`:\r\n\r\n    $ cat data | gr8 'map{split()[1]}.map(&:to_i).sum'\r\n    300\r\n\r\n`sum_i()` is a short-hand for `map(&:to_i).inject(0,:+)`:\r\n\r\n    $ cat data | gr8 'map{split()[1]}.sum_i'   # or 'sum_f' for float\r\n    300\r\n\r\nCommand-line opiton '-F' splits each line into array:\r\n\r\n    $ cat data | gr8 -F 'map{self.inspect}'\r\n    [\"Haruhi\", \"100\"]\r\n    [\"Mikuru\", \"80\"]\r\n    [\"Yuki\", \"120\"]\r\n    $ cat data | gr8 -F 'map{self[1]}.sum_i'   # or 'map{|a|a[1]}.sum_i'\r\n    300\r\n\r\nCommand-line option '-C n' selects column (1-origin):\r\n\r\n    $ cat data | gr8 -C 2 'map{self}'\r\n    100\r\n    80\r\n    120\r\n    $ cat data | gr8 -C 2 'sum_i'\r\n    300\r\n\r\nCalculates average of numbers instead of total:\r\n\r\n    $ cat data | gr8 -C 2 'map(&:to_i).avg'\r\n    300.0\r\n    $ cat data | gr8 -C 2 'avg_i'\r\n    300.0\r\n\r\nCompared to `ruby -ne`:\r\n\r\n    $ cat data | ruby -ne 'BEGIN{t=0};t+=$_.split[1].to_i;END{p t}'\r\n    300\r\n    $ cat data | ruby -ane 'BEGIN{t=0};t+=$F[1].to_i;END{p t}'\r\n    300\r\n\r\n\r\n## Example 2: Generating Shell Commands\r\n\r\nAssume that there are some image files:\r\n\r\n    $ ls\r\n    img1.jpg      img2.jpg      img3.jpg\r\n    img4.png      img5.png      img6.png\r\n\r\nSelect PNG files:\r\n\r\n    $ ls | gr8 'grep(/(.*)\\.png$/)'\r\n    img1.png\r\n    img2.png\r\n    img3.png\r\n\r\nPrints new filename replacing '.png' with '.jpg':\r\n\r\n    $ ls | gr8 'grep(/(.*)\\.png/) { \"#{$1}.jpg\" }'\r\n    img1.jpg\r\n    img2.jpg\r\n    img3.jpg\r\n\r\nPrints OS command to convert PNG file into JPG:\r\n\r\n    $ ls | gr8 'grep(/(.*)\\.png/) { \"convert #{$1}.png #{$1}.jpg\" }'\r\n    convert img1.png img1.jpg\r\n    convert img2.png img2.jpg\r\n    convert img3.png img3.jpg\r\n\r\nYou may want quotes file name with single quotation:\r\n\r\n    $ ls | gr8 'grep(/(.*)\\.png/) { \"convert #{$1.q}.png #{$1.q}.jpg\" }'\r\n    convert 'img1'.png 'img1'.jpg\r\n    convert 'img2'.png 'img2'.jpg\r\n    convert 'img3'.png 'img3'.jpg\r\n\r\nOr double quotation:\r\n\r\n    $ ls | gr8 'grep(/(.*)\\.png/) { \"convert #{$1.qq}.png #{$1.qq}.jpg\" }'\r\n    convert \"img1\".png \"img1\".jpg\r\n    convert \"img2\".png \"img2\".jpg\r\n    convert \"img3\".png \"img3\".jpg\r\n\r\nRun os commands after you confirmed them:\r\n\r\n    $ ls | gr8 'grep(/(.*)\\.png/) { \"convert #{$1.qq}.png #{$1.qq}.jpg\" }' | sh\r\n\r\n\r\n## Example 3: File Manipulation\r\n\r\n`Kernel#fu()` is a short-hand which returns `FileUtil` module.\r\nUsing it, You can rename or move files very easily.\r\n\r\nAssume that there are several PNG files:\r\n\r\n    $ ls | gr8 'grep(/^a(\\d+)/)'\r\n    a1.png\r\n    a2.png\r\n    a3.png\r\n\r\nAnd you want to rename them to other names:\r\n\r\n    $ ls | gr8 'grep(/^a(\\d+)/) { \"b#{$1.to_i+100}.png\" }'\r\n    b101.png\r\n    b102.png\r\n    b103.png\r\n\r\n`fu.mv` is a short-hand to `require \"fileutils\"; FileUtils.mv`:\r\n\r\n    $ ls | gr8 'grep(/^a(\\d+)/) { fu.mv \"a#{$1}.png\", \"b#{$1.to_i+100}.png\" }'\r\n    $ ls b*.png\r\n    b101.png   b102.png   b103.png     # renamed from 'a1.png', 'a2.png' and 'a3.png'\r\n\r\n(Experimental)\r\n\r\n`gr8` provides more convenient methods to mapipulate files:\r\n\r\n    $ ls | gr8 'copy_as    { sub(/\\.htm$/, \".html\") }'\r\n    $ ls | gr8 'copy_as!   { sub(/\\.htm$/, \".html\") }'  # overwrite existing file\r\n    $ ls | gr8 'rename_as  { sub(/\\.htm$/, \".html\") }'\r\n    $ ls | gr8 'rename_as! { sub(/\\.htm$/, \".html\") }'  # overwrite existing file\r\n    $ ls | gr8 'copy_to  { \"some/where/directory/\" }'\r\n    $ ls | gr8 'copy_to! { \"some/where/directory/\" }'   # overwrite existing file\r\n    $ ls | gr8 'move_to  { \"some/where/directory/\" }'\r\n    $ ls | gr8 'move_to! { \"some/where/directory/\" }'   # overwrite existing file\r\n\r\n\r\n## References\r\n\r\n\r\n### Kernel#fu()\r\n\r\nReturns `FileUtils` class object.\r\n\r\nExample:\r\n\r\n    $ ls | gr8 'grep(/(.*)\\.png/){fu.mv \"#{$1}.png\", \"#{$1}.jpg\"}'\r\n\r\n\r\n### String#q(), #qq()\r\n\r\n`q()` quotes string with single-quotation, with escaping singile-quotation with backslash.\r\n\r\n`qq()` quotes string with double-quotation, with escaping singile-quotation with backslash.\r\n\r\nThese are convenient when file name contains spaces.\r\n\r\nExample:\r\n\r\n    $ echo 'Image 1.png' | gr8 'grep(/(.*)\\.png/){\"convert #{$1.q}.png #{$1.q}.jpg\"}'\r\n    convert 'Image 1'.png 'Image 1'.jpg\r\n    $ ls | gr8 'grep(/(.*)\\.png/){\"convert #{$1.qq}.png #{$1.qq}.jpg\"}'\r\n    convert \"Image 1\".png \"Image 1\".jpg\r\n\r\n\r\n### Enumerable#transform(){...}, #xf(){...}\r\n\r\nSimilar to `map()`, but it sets each item as self in block argument.\r\n\r\nExample:\r\n\r\n    $ ls *.png | gr8 'xf{self}'\r\n    A.png\r\n    B.png\r\n    C.png\r\n    $ ls *.png | gr8 'xf{sub(/\\.png/, '.jpg')}'\r\n    A.jpg\r\n    B.jpg\r\n    C.jpg\r\n\r\nSource code:\r\n\r\n    def transform(&block)\r\n      collect {|x| x.instance_exec(x, &block) }\r\n    end\r\n    alias xf transform\r\n\r\n\r\n### Enumerable#map(){...}\r\n\r\nExtended to set each item as self in block argument of `map()`.\r\nIf you want original `map()`, use `collect()` instead.\r\n\r\nExample:\r\n\r\n    $ ls *.png | gr8 'map{self}'\r\n    A.png\r\n    B.png\r\n    C.png\r\n    $ ls *.png | gr8 'map{sub(/\\.png/, '.jpg')}'\r\n    A.jpg\r\n    B.jpg\r\n    C.jpg\r\n\r\nSource code:\r\n\r\n    alias __map map\r\n    def map(&block)\r\n      __map {|x| x.instance_exec(x, &block) }\r\n    end\r\n\r\n\r\n### Enumerable#select(){...}\r\n\r\nExtended to set each item as self in block argument of `select()`.\r\nIf you want original `select()`, use `find_all()` instead.\r\n\r\nExample:\r\n\r\n    $ ls *.png | gr8 'select{self}'\r\n    A.png\r\n    B.png\r\n    C.png\r\n    $ ls *.png | gr8 'select{start_with?(\"B\")}'\r\n    B.jpg\r\n\r\nSource code:\r\n\r\n  alias __select select\r\n  def select(&block)\r\n    __select {|x| x.instance_exec(x, &block) }\r\n  end\r\n\r\n\r\n### Enumerable#sum()\r\n\r\nSame as `inject(0, :+)`.\r\n\r\nExample:\r\n\r\n    $ cat file\r\n    10.5\r\n    20.5\r\n    30.5\r\n    $ cat file | gr8 'map(&:to_f).sum'\r\n    61.5\r\n\r\n\r\n### Enumerable#sum_i(), #sum_f()\r\n\r\nSame as `map(&:to_i).inject(0, :+)` or `map(&:to_f).inject(0, :+)`\r\n\r\nExample:\r\n\r\n    $ cat file\r\n    10.5\r\n    20.5\r\n    30.5\r\n    $ cat file | gr8 'sum_i'\r\n    60\r\n    $ cat file | gr8 'sum_f'\r\n    61.5\r\n\r\n\r\n### Enumerable#avg()\r\n\r\nReturns average of numbers.\r\n\r\nExample:\r\n\r\n    $ cat file\r\n    10.1\r\n    20.2\r\n    30.3\r\n    $ cat data |gr8 'map(&:to_i).avg'\r\n    20.0\r\n\r\n\r\n### Enumerable#avg_i(), #avg_f()\r\n\r\nSame as `map(&:to_i).avg` or `map(&:to_f).avg`.\r\n\r\nExample:\r\n\r\n    $ cat file\r\n    10.1\r\n    20.2\r\n    30.3\r\n    $ cat data |gr8 'avg_i'\r\n    20.0\r\n    $ cat data |gr8 'avg_f'\r\n    20.2\r\n\r\n\r\n### Enumerable#sed(pattern, replacing), #sed(pattern){...}\r\n\r\nReplaces the first pattern in each line with replacing string or block.\r\nInternally, `sed()` calls `String#sub()`.\r\n\r\nExample:\r\n\r\n    $ ls *.png\r\n    A.png\r\n    B.png\r\n    C.png\r\n    $ ls *.png | gr8 'sed(/png/, \"jpg\")'\r\n    A.png\r\n    B.png\r\n    C.png\r\n\r\nSource code:\r\n\r\n    def sed(pat, str=nil, &block)\r\n      if block_given?\r\n        collect {|s| s.sub(pat, &block) }\r\n      else\r\n        collect {|s| s.sub(pat, str) }\r\n      end\r\n    end\r\n\r\n\r\n### Enumerable#gsed(pattern, replacing), #gsed(pattern){...}\r\n\r\nReplaces all of pattern in each line with replacing string or block.\r\nInternally, `gsed()` calls `String#gsub()`.\r\n\r\nExample:\r\n\r\n    $ ls *.png\r\n    A1-1.png\r\n    A1-2.png\r\n    A1-3.png\r\n    $ ls *.png | gr8 'sed(/\\d+/, \"00\\\\&\")'\r\n    A001-1.png\r\n    A001-2.png\r\n    A001-3.png\r\n    $ ls *.png | gr8 'gsed(/\\d+/, \"00\\\\&\")'\r\n    A001-001.png\r\n    A001-002.png\r\n    A001-003.png\r\n\r\nSource code:\r\n\r\n    def gsed(pat, str=nil, &block)\r\n      if block_given?\r\n        collect {|s| s.gsub(pat, &block) }\r\n      else\r\n        collect {|s| s.gsub(pat, str) }\r\n      end\r\n    end\r\n\r\n\r\n### Enumerable#paths(), #paths{...}\r\n\r\nConverts each item into `Pathname` object.\r\nLibrary `pathname` will be loaded automatically.\r\n\r\nExample:\r\n\r\n    $ /bin/ls | gr8 'paths{|x| \"#{x}: #{x.ftype}\"}'\r\n    MIT-LICENSE: file\r\n    README.txt: file\r\n    Rakefile: file\r\n    bin: directory\r\n    lib: directory\r\n    test: directory\r\n\r\nSource code:\r\n\r\n  def paths(&block)\r\n    require \"pathname\" unless defined?(Pathname)\r\n    if block_given?\r\n      collect {|s| x = Pathname(s); x.instance_exec(x, &block) }\r\n    else\r\n      collect {|s| Pathname(s) }\r\n    end\r\n  end\r\n\r\n\r\n### Enumerable#copy_to{...}, #copy_to!{...}\r\n\r\n(Experimental)\r\n\r\nCopy files into destination directory, without renaming basename.\r\n\r\n* Block argument should return destination directory name.\r\n* `copy_to()` skips when destination file already exists.\r\n* `copy_to!()` overwrites when destination file already exists.\r\n* Both skips copying when destination directory doesn't exist.\r\n\r\n\r\n### Enumerable#mkdir_and_copy_to{...}, #mkdir_and_copy_to!{...}\r\n\r\n(Experimental)\r\n\r\nSimilar to `copy_to()` or `copy_to!()` except creating destination directory when not exist.\r\n\r\n\r\n### Enumerable#move_to{...}, #move_to!{...}\r\n\r\n(Experimental)\r\n\r\nMove files into destination directory, without renaming basename.\r\n\r\n* Block argument should return destination directory name.\r\n* `move_to()` skips when destination file already exists.\r\n* `move_to!()` overwrites when destination file already exists.\r\n* Both skips moving files when destination directory doesn't exist.\r\n\r\n\r\n### Enumerable#mkdir_and_move_to{...}, #mkdir_and_move_to!{...}\r\n\r\n(Experimental)\r\n\r\nSimilar to `move_to()` or `move_to!()` except creating destination directory when not exist.\r\n\r\n\r\n### Enumerable#copy_as{...}, #copy_as!{...}\r\n\r\n(Experimental)\r\n\r\nCopy files into destination directory, with renaming basename.\r\n\r\n* Block argument should return destination file name.\r\n* `copy_as()` skips when destination file already exists.\r\n* `copy_as!()` overwrites when destination file already exists.\r\n* Both skips copying when destination directory doesn't exist.\r\n\r\n\r\n### Enumerable#mkdir_and_copy_as{...}, #mkdir_and_copy_as!{...}\r\n\r\n(Experimental)\r\n\r\nSimilar to `copy_as()` or `copy_as!()` except creating destination directory when not exist.\r\n\r\n\r\n### Enumerable#rename_as{...}, #rename_as!{...}\r\n\r\n(Experimental)\r\n\r\nMove files into destination directory, with renaming basename.\r\n\r\n* Block argument should return destination file name.\r\n* `rename_as()` skips when destination file already exists.\r\n* `rename_as!()` overwrites when destination file already exists.\r\n* Both skips moving when destination directory doesn't exist.\r\n\r\n\r\n### Enumerable#mkdir_and_rename_as{...}, #mkdir_and_rename_as!{...}\r\n\r\n(Experimental)\r\n\r\nSimilar to `rename_as()` or `rename_as!()` except creating destination directory when not exist.\r\n\r\n\r\n## License and Copyright\r\n\r\n$License: MIT License $\r\n\r\n$Copyright: copyright(c) 2015 kuwata-lab.com all rights reserved $\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}